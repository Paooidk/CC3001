# -*- coding: utf-8 -*-
"""Ejercicio 7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19TUr4BG8iOVMg8psyjatGLZYgl6v6h2q

# Nombre: Paola López Neira

### Ejercicio 5.1
En este ejercicio se trata chequear si una secuencia de paréntesis está bien escrita. Si hay solo un tipo de paréntesis, por ejemplo ( y ), una secuencia correcta sería (()(())) y una incorrecta seria (()))()( o ()). Ésta sería una tarea fácil de responder, pues bastaría con llevar un contador de paréntesis abiertos, que se incrementa cuando se encuentra un ( y se decrementa cuando se encuentra un ) y se va chequeando que este contador nunca sea negativo y cuando se termine la secuencia el contador quede en 0.
"""

def chequeo(s): # s es un strings con una secuencia de paréntesis ( )
    i = 0 # contador de paréntesis abiertos
    for c in s:
        if c == "(":
            i +=1
        else:
            i -=1
        if i < 0: break
    if i == 0: return "CORRECTA"
    else : return "INCORRECTA Contador = "+str(i)

"""Probemos con los ejemplos :"""

print(chequeo("(()(()))"))
print(chequeo("(())(()"))
print(chequeo("(()))"))

"""El problema se hace bastante más complejo cuando hay más de un tipo de paréntesis, por ejemplo (), [] y {} y ellos tienen que estar balanceados respectivamente, es decir se permite {([]{()})} o [{()[]}] pero no ([{]}) o {[()}]
Esto se puede hacer con la ayuda de un Stack o Pila, inicialmente vacío.
Luego, por cada símbolo que se va chequeando:
   - si es un abre paréntesis entonces se pone en el stack y se continúa con el chequeo del próximo símbolo
   - si es un cierra paréntesis entonces se revisa el elemento del tope del stack
    - si el stack está vacío, entonces la secuencia está mal escrita y ahí termina el proceso.
    - si el stack no está vacío, se extrae el símbolo del tope y se chequea si es un abre paréntesis que coincide con el tipo de cierra paréntesis que se encontró. Si es así, se continúa con el chequeo del próximo símbolo, si no la fórmula está mal escrita y ahí termina el proceso.

Al final del proceso se debe chequear si el stack esta vacío, con lo cual se comprueba que la fórmula esta bien escrita. Si no, la fórmula está mal escrita.

Se le pide escribir una funcion chequeo2 que reciba 3 parametros de tipo string: ``s``, ``a`` y ``b``. En ``s`` viene la secuencia de paréntesis a chequear, en ``a`` vienen los abre parentesis permitidos y en ``b`` los cierra paréntesis respectivos de modo que en ``b[i]`` está el paréntesis que cierra a ``a[i]``.
Por simplicidad use la implementacion de pila que viene a continuacion
"""

class Pila:
    def __init__(self):
        self.s=[]
    def push(self,x):
        self.s.append(x)
    def pop(self):
        assert len(self.s)>0
        return self.s.pop() # pop de lista, no de Pila
    def is_empty(self):
        return len(self.s)==0

"""Y escriba la funcion a continuación:"""

def chequeo2(s, a, b):
    #Escriba aquí su función
    stack = Pila()
    for char in s:
      if char in a:
        stack.push(char)
      else:
        if stack.is_empty():
          return "Incorrecto"
        curr_char = stack.pop()
        for i in range(len(b)):
          if curr_char == a[i]:
            if char != b[i]:
              return "Incorrecto"
    if stack.is_empty():
      return "Correcto"
    else:
      return "Incorrecto"

"""Pruébela con los siguientes casos:"""

print(chequeo2("(()())","(",")"))
print(chequeo2("(()]","([",")]"))
print(chequeo2("{([]{()})}","{[(","}])"))
print(chequeo2("{([]()})}","{[(","}])"))
print(chequeo2("{<{<>}>}", "{<","}>"))
print(chequeo2("{<{<>>}>}", "{<","}>"))

