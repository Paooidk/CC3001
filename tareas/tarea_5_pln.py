# -*- coding: utf-8 -*-
"""Tarea 5 PLN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E0HJReSOGBqr6kySmlZnu-chjWF-NlK_

# CC3001 Otoño 2022 Tarea 5 [Paola López Neira]

## ABB+

### Profesores
Sección 1 Iván Sipirán •
Sección 2 Patricio Poblete •
Sección 3 Nelson Baloian
"""

!pip install aed-utilities

import aed_utilities as aed
import numpy as np

"""## Introducción

Un *árbol de búsqueda binaria+* (*ABB+*) es un ABB modificado para que las $n$ llaves que están almacenadas en los nodos internos aparezcan además en las hojas, en orden ascendente,de izquierda a derecha. La última hoja de la derecha tiene una llave especial ``inf``("$+\infty$"), como se ve en el siguiente ejemplo:

![Ejemplo ABB+](https://drive.google.com/uc?export=view&id=1-SAU_CJ_nHd63KgOpZAUO1-AiiHlvu6g)

Para buscar una llave $x$ en este árbol, comenzamos en la raíz y vamos preguntando si $x$ es $\le$ que la llave de ese nodo. Si la respuesta es que sí, bajamos hacia la izquierda; si no, bajamos hacia la derecha. Al llegar finalmente a una hoja, ahí se compara por igualdad para ver si la llave buscada está ahí o no.

En comparación con un ABB, el correspondiente ABB+ hace búsquedas más eficientes, porque hace solo una pregunta por nodo, en lugar de las dos que se hacen en el ABB (primero preguntando por igualdad y luego por menor o mayor).

Nótese que un ABB+ vacío (cero llaves) consiste de una sola hoja con ``inf``en su interior.

## Objetivo de la tarea

Su trabajo consiste en implementar las clases ``Arbol``, ``Nodoi`` y ``Nodoe`` y los métodos ``insert`` y ``search`` en todos lugares en donde corresponda (no se pide implementar ``delete``). Luego debe ejecutar los casos de prueba que se indica.

Esta tarea se puede resolver con recursividad o sin recursividad. Usted debe decidir cuál enfoque usar.

En el código que aparece a continuación usted debe agregar todo lo necesario para que la implementación esté completa.
"""

class Nodoi:
    def __init__(self, izq, info, der):
        self.izq=izq
        self.info=info
        self.der=der

    def insert(self, a):
        assert a != self.info #se comprueba que el dato no esté en el árbol
        if self.info > a: #continua por la izquierda
          return Nodoi(self.izq.insert(a), self.info, self.der)
        else: #caso contrario se continua por la derecha
          return Nodoi(self.izq, self.info, self.der.insert(a))

    def search(self, a):
        if self.info >= a:
          return self.izq.search(a) #se continua recursivamente por la izquierda
        else: #caso contrario continua por la derecha
          return self.der.search(a)



class Nodoe:
    def __init__(self,info):
        self.info=info

    def insert(self, a):
      if self.info < a:
        return Nodoi(Nodoe(self.info), a, Nodoe(a))
      else:
        return Nodoi(Nodoe(a), a, Nodoe(self.info))

    def search(self, a):
        if self.info == a: #revisamos si está el elemento
          return a
        else:
          return None #caso contrario retorna None

class Arbol:
    def __init__(self,raiz=Nodoe(np.inf)):
        self.raiz=raiz

    def insert(self, a):
      self.raiz = self.raiz.insert(a)

    def search(self, a):
      return self.raiz.search(a)

    def dibujar(self):
      btd = aed.BinaryTreeDrawer(fieldData="info", fieldLeft="izq", fieldRight="der", classNone=Nodoe)
      btd.draw_tree(self, "raiz")

"""La siguiente función es útil para probar su implementación:"""

def test(a,x):
    print(x, "está" if a.search(x) is not None else "no está")

"""## Prueba 1: Construir un árbol por inserciones sucesivas"""

a=Arbol()
a.insert(40)
a.insert(25)
a.insert(32)
a.insert(90)
a.insert(62)
a.insert(55)
a.insert(70)
a.dibujar()
test(a,62)
test(a,95)

"""## Prueba 2: Agregar una llave que no estaba y buscarla"""

a.insert(95)
a.dibujar()
test(a,95)

"""## ¿Qué hay que entregar?

Usted debe crear una copia de este documento (del menú seleccionar "Archivo" o "File" y de ahi la opción "guardar copia en Drive" o "save a copy in Drive"). Este nuevo documento (notebook de Colab) es el que debe modificar para luego compartirlo con la opción "Cualquier usuario de internet con este enlace puede ver esto" (o “Anyone on the internet with this link can view”). Esta opción se encuentra disponible en la parte superior derecha de su notebook, en el botón "Compartir" (o "Share"). Una vez que tenga disponible el enlace, colocarlo en la descripción de la entrega de su tarea. No olvide colocar su nombre dentro del notebook.
"""
